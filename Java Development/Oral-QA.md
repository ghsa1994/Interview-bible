# 数据库
## mysql的锁
### 说一下mysql的表锁和行锁
mysql常用的引擎主要有myisam和innoDB，在mysql5.5及其以前的时候mysql使用myisan只支持表锁，不会发生死锁，发生锁冲突几率高，并发低。在mysql5.6以后，mysql默认使用的引擎是innoDB,支持表锁和行锁，行锁会发生死锁，发生锁冲突几率低，并发高。
###	innoDB在什么时候使用表锁
mysql的行锁是通过索引加载的，如果行锁语句没有使用索引，则会全表扫描，就会使用表锁。还有在修改表结构的时候可能也会使用表锁。
###	行锁有什么类型
有共享锁和排他锁两种类型，共享锁也就是读锁，当一个事物对数据上读锁的时候，允许其他事物对数据进行读取和上读锁，不允许修改和上排他锁。排他锁也就是写锁，上锁后只允许其他事务读取，不允许上任何锁。
###	在什么时候会加排他锁
在insert delete update 等操作时，会默认加上排他锁，也可以在查询的时候加上for update也会加上写锁。
##	mysql的引擎
###	说一下myisam和innoDB的不同
myisam在mysql5.5之前用的，主要特点是访问速度快，但不支持事务，不支持外键。InnoDB是mysql5.6之后的默认引擎，支持事务，支持外键。但是写效率会低一些，也会占用更大的空间来存储数据和索引。
###	说一下myisam和innoDB索引方面的不同
myisam的索引和数据是分开的，使用B+树构建索引，叶子结点存住的为索引的列在磁盘上的位置。而innerDB的索引和数据都保存在一个文件中，叶子结点是存储的整行的数据。
myisam可以没有主键索引，innoDB会根据规则创建主键索引。
myisam的辅助索引和主键索引结构上没有差别，辅助索引由于可能会有重复的情况，所以即使是等值查询，也会按照范围查询的方式在辅助索引树上检索数据。innoDB的辅助索引树上存储的是该条数据的主键，辅助索引查询的时候会使用主键去主键索引树上查询记录
###	组合索引abc问题
如果创建组合索引abc三个字段排序，那么
三个字段在where条件里面使用相等判断，不管顺序怎么样，都会走索引。
如果只有a和c使用相等判断，那么a会走索引，c不会走索引
如果三个条件都有，但是其中b做了范围判断，那么ab会走索引，c不会走索引
如果使用排序那么也遵循靠左原则，a如果有等值判断，那么后面就会使用到索引效果。
###	为什么使用组合索引
减小开销，每多建一个索引就会增加写操作和对磁盘空间的开销
覆盖索引，为了避免回表查询。
效率高，组合索引可以大大降低通过索引筛选出来的数据量。



##	mysql的优化
###	sql语句的优化
尽量能使用到索引，避免全表扫描，避免使用前模糊，不等于等逻辑查询
###	怎么查看sql是否走了索引
使用explain关键字查看，查看type字段的输出，如果是const就是使用了唯一索引或者主键，返回一条数据。使用eq_ref/ref/fulltext/subquery等就是可能用到了索引，如果使用all了就是全表扫描了，就需要优化。
###	怎么避免回表
覆盖索引和索引下推技术。覆盖索引就是，如果只查找几个列的数据，那么尽量建组合索引，这样数据库就能在辅助索引树上查到所需要的数据，避免再次回主索引树上查找整条数据，有效的减少IO.
##	数据库的事务
###	说一下sql的隔离级别
读取未提交，最低的隔离级别，允许读取未提交的数据变更，可能会导致脏读，幻读和不可重复读。
读取已提交，允许读取已提交的数据，可以防止脏读，但是还有可能导致幻读和不可重复读。除了innon db大多数数据库都是这种隔离级别
可重复读，同一事务中对同一字段的多次读取结果都是一样的，除非被本身事务修改，可以阻止脏读和不可重复读，但是幻读还有可能发生。innon DB就是使用了可重复读。
可串行化，最高的隔离级别，所有的事务逐个执行执行。一般只在需要保证数据高一致性的情况下才会使用
###	你说下脏读、幻读、不可重复读是什么
脏读，在读取未提交的隔离级别下，有一个事务读取了另一个事务未提交的数据，另一个事务回滚了，那么这就是脏读
不可重复读，在读取未提交和读取已提交的隔离级别下，一个事务读取了一个数据，另一个事务修改了这个数据，等这个事务下一次读取这个数据就和上一次的不一样了。
幻读，在除了可串行化的隔离级别外的所有隔离级别下，一个事务读了一批数据，然后另个事务在插入了几条数据，那么这个事务第二次读取就会多几条数据。
##	关系型数据库和非关系型数据的区别
关系型数据库是基于关系模型的的数据库，使用二维表来存储数据，表之前可以存在约束关系，可以通过sql去查询，比较适用于存储有复杂结构的数据
非关系型数据库不依赖于关系模型，使用键值对，文档，列族等来存储数据，表之前没有明确的关系，不能用sql去查，主要关注的是高性能，可以处理大量非结构化的数据
###	什么是关系模型和关系代数理论
关系模型是一种基于关系代数理论的数据模型，它将数据表示为关系，每一个关系都有一组属性相关的数据组成一个二维表，每个属性都有一个名称和数据类型，每一行数据都代表了一个实体或者对象，包含该实体的属性值，关系模型是现在数据库管理系统的核心。是保证数据一致性完整性和安全性的重要手段之一。
关系代数理论就是用于关系型数据库的数学理论，这个理论把数据视为一组关系。


#	Spring
##	Spring基本概念
###	说一下Spring的IOC和DI还有AOP
IOC就是控制反转，在传统的JavaSE程序设计中，我们直接在对象内部通过new的方式创建对象，就是程序主动去创建依赖对象。而IOC则是把设计好的对象交给IOC容器，让容器来控制对象的生命周期。
DI是依赖注入，其实是IOC的不同角度的表述，也就是说应用程序依赖IOC容器注入当前对象所使用的外部资源
AOP是面向切面编程，AOP的关键单元是切面而不是面向对象的中的对象。一般用于日志，事务管理，权限等。

###	*你在哪里有用过AOP吗*
在之前的汇丰的项目中有用过，我们的日志服务器在国外，但是我们程序中的日志有涉及到客户的敏感信息，根据国家规定，这种情况是不允许的，所以我们做了一个AOP的组件用来对用户的敏感信息进行脱敏处理。

###	Spring实例化bean的作用域
Spring的Bean有5个作用域，单例，原形，request，session，全局session。
单例是默认的作用域，每一个IOC容器都拥有一个唯一的实例对象。
原形是一个bean的定义，可以有多个对象。
request是一个http请求会产生一个bean对象，每一个http请求都有有实例，只在基于web的Spring上下文中出现
Session限定在一个httpsession的生命周期中，同样也只基于web的Spring
全局session的作用域位全局的httpsession的生命周期，同样也只是出现在Spring Web项目中
###	说一下SpringBean的生命周期
在Spring项目中普通的Java类会通过BeanDefinition接口变为一个SpringBean,SpringBean的生命周期有实例化、赋值、初始化、销毁四个阶段。
###	说一下什么是Spring容器，有哪几种容器，简单的介绍一下
Spring容器是Sping的核心，可以创建对象。并且管理每个创建好的对象形成一个应用程序的组件。
Spring容器有两种BeanFactory和ApplicationContext。BeanFactory是一个简单的Spring容器，主要提供了依赖注入的基础的支持。ApplicationContext在BeanFactory的基础上添加了一些企业级的东西，更全面。比如添加了资源访问，自动装配，事件传递，各种应用层的context的实现
###	过一下过滤器、拦截器和监听器的区别
过滤器是基于容器的，在请求到达Servlet之前就能到过滤器，主要作用是过滤一些符合要求的请求，比如说设置字符编码，敏感信息输入，url级别访问权限，压缩响应信息等。
拦截器是基于SpringMVC,是才用AOP设计思想的，可以用来权限控制，日志，性能监控，处理cookie，异常处理等。监听器也是在容器上注册的，监听器是想获取这个事件发生的详细信息，并不想干预这个事件本身
###	Spring用到的设计模式
单例模式，Spring默认创建bean是单例模式。
工厂模式，Spring使用BeanFactory和ApplicationContest来创建对象
策略模式，例如使用resource的实现类，针对不同的资源文件，实现了不同的资源获取策略
代理模式，Spring的AOP功能用到了JDK的动态代理
模板模式，Spring中把相同的部分代码放在父类中，将不同的代码放入不同的子类中，用来解决代码重复的问题，比如JpaTemplate,RestTemplate等
适配器模式，Spring的AOP增强和通知使用了适配器模式
观察者模式，Spring事件驱动模型。
桥接模式，根据客户的需求能够动态切换不同的数据源。
###	Spring可以通过哪些方式对@value进行注入
字符串直接注入
注入表达式结果
注入其他Bean的属性
注入了文件资源
使用占位符注入
注入操作系统属性systemProperties
注入表达式结果
###	Spring使用了哪些代理模式
使用了JDK动态代理和cglib代理。一般情况下如果是对象有接口的那么就会使用jdk动态代理，如果没有接口则使用cglib代理，当然可以指定使用哪个代理，使用@EnableAspectJAutoproxy(proxyTargetClass = true)，True为cglib代理，false为jdk动态代理
####	两种代理模式有什么不同
jdk是用java反射机制来实现的，性能稍微慢一些，但是不会成为性能瓶颈，只能代理实现了接口的目标对象。cglib是通过继承的目的来实现的，所以可以代理任何目标对象，效率更高些。


##	SpringBoot基本概念
###	说一下SpringBoot的核心注解
SpringBoot的核心注解是SpringBootApplication，它是有3个注解构成的，SpringBootConfiguration、EnableAutoconFiguration和ComponentScan.
SpringBootConfiguration表示这是一个配置文件类，会被ComponentScan扫描到，它的作用相当于一个Configuration注解，然后Spring会扫描添加了Configuration的类获取其中的配置信息
EnableAutoconFiguration是启动自动配置的注解，使用它之后，SpringBoot就会根据项目中引入的JAR包，自动配置项目中的配置项。
ComponentScan是配置组件扫描的指令，所扫描当前包和子包下面文件中的注解
###	SpringBoot怎么解决跨域问题
增加跨域配置类，重写webmvcConfigurer,使用@Crossorigin注解，搞个自定义过滤器，手动设置接口的响应头。如果是前后端分离的那么也可以在Nginx中配置。如果有使用Spring Security，注意配置cors在过滤器上面。
##	Spring事务
###	Spring事务在什么情况下会失效
一般情况下是，没有使用public，使用final修饰，内部调用，多线程调用，数据库不支持，没有被Spring管理，错误的传播类型，手动处理了异常，抛出来了别的异常等。
###	Spring事务有哪几种实现方式
使用Transactional注解实现声明式事务，使用transactionTemplate做编程式事务，使用AOP配置事务和使用transactionProxyFactoryBean的声明式事务管理。
###	Spring事务的传播机制
Spring的传播机制有required、surpports，MANDATORY ，REQUIRES_NEW，NOT_SUPporTED，NEVER 和NESTED 。默认的隔离级别是required，就是上下文有事务的时候就用这个事务，如果没有事务就创建一个事务。surpports有事务就加入事务，没有事务就用非事务执行。MANDATorY如果上下文没有事务就抛出异常。REQUIRES_NEW内存都创建一个新的事务，当上下文存在事务的情况下就先挂起执行新的事务。Not_SUPporTED是有事务的情况下就挂起，用非事务方式执行新的代码。never是存在事务抛出异常，没有事务则在没有事务上执行。NESTED嵌套事务是上下午存在事务，则嵌套事务执行，否则就新建事务。
###	spring事务的隔离级别
Spring事务的隔离级别默认情况下是使用数据库的设置，其他4种隔离级别和数据库的隔离级别是一样的。
##	SpringCloud
###	feign的本质
feign的本质是一个http调用客户端，它的本质是动态代理，feign会根据注解来构建请求接口。
### SpringCloud分布式网关怎么实现缓存
SpringCloud gateway是支持继承redis缓存的，redis缓存可以提高网关性能。Nacos gateway本身是不支持redis缓存的，可以用拦截器来实现对redis的集成。
### SpringCloud gateway网关限流策略
默认使用令牌桶策略算法，还有漏桶策略，计数器策略，IP地址显示等。令牌桶主要的是优点是能一定程度的突发流量，确定是无法应对短时间内大量请求。漏桶能精准的控制请求速度，但是处理请求时间不固定，间隔时间不太相等的服务时会有影响。计时器策略是指一秒通过多少请求，优点是简单，缺点长时间的大流量请求就不太适用了，IP限制的时主要防止恶意请求的。
### Nacos Gateway限流策略
默认是QPS限流的，还支持并发线程数限流，响应时间限流和漏桶限流等。

##	SpringSecurity
###	token续期有哪几种方案
主要有单token和双token的方案，如果是单token的话，就是只有一个请求token，然后发送请求之后，如果token有效就能正确的返回请求结果，如果token失效，前端就再次请求刷新token，后端验证token是否超过了最大时间或者最大刷新次数，然后返回token重新访问接口。
双token就是有一个access_token和一个refresh_token，两个token都有各自的过期时间，如果请求token过期了就用refresh_token请求刷新请求token。
###	Oauth2有几种模式
有授权码模式，隐藏式，密码模式，还有凭证式。授权码模式就是第三方应用首先会申请到一个授权码，然后第三方应用服务端再用这个授权码去申请获得令牌。隐藏式就是一个token，直接把token给前端。密码是也就是第三方应用拿到用户的密码直接用密码去访问资源。凭证式就是应用去使用一个资源用户id去访问资源

#	Java基础相关
##	JVM和java基础
###	String为什么是Final的
为了实现字符串池，为了安全，为了实现String可以创建hashcode不可变性
字符串池是为了在运行的时候节约空间，如果String可变的话，那它指向的值会一起变，就无法实现字符串池了
安全有两部分是系统安全和线程安全，String是比较底层的，JDK组件很多核心组件都是用Java编写的，java的开发者不希望程序员可以修改这个类，以免影响系统安全。我们在很多时候使用String去传递比较敏感的信息，如果可以修改则会有系统上的漏洞。线程安全上，一个字符串可能会被多个线程调用，这样不用因为线程安全问题而在字符串上使用同步
hashcode不可变性，因为字符串的是不可变的，所以在创建的时候hashcode 已经被缓存了，不需要重新计算，所以使用String作为HashMap的键对象处理速度会明显的快很多。
###	hashcode相同，equals一定相同么
不一定，hashcode算法只能保证字符串一样所计算出来的hashcode是一样的，但是不同对象计算出来的hashcode也就可能一样。equals会比较两个String的内容是否一样。
###	==和equals的区别
“==”是运算符，如果是基本数据类型，则比较存储的值；如果是引用数据类型，则比较所指向对象的地址值。
equals是object的方法，比较的是所指向的对象的地址值，一般情况下，重写之后比较的是对象的值。
###	抽象类和普通类的区别
1.	抽象类的存在就是为了被继承，不能实例化，普通类存在是为了实例化一个对象。
2.	抽象类的子类必须重写抽象类中的抽象方法。普通类可以选择重写或者不重写父类的方法，也可以直接调用父类的方法
3.	抽象类必须使用abstract来修饰，普通类不用
4.	普通类和抽象类都可以含有普通成员和普通方法
5.	普通类和抽象类可以集成别的类或者被别的类集成
6.	抽象类和普通类的属性和方法都可以通过子类对象来调用
###	Exception和Error的区别
Exception主要是程序发生了可以预见的运行时错误，比如说数组越界，空指针，转换错误等，Error是一些无法预见的错误，像是虚拟机产生异常了，内存溢出或者死锁了。
一般Exception需要捕获处理，Error无法预见可以捕获，但是没有必要捕获处理。他们都是继承Throwable的
###	String、StringBuffer和StringBuilder的区别
String是不可变的，它每次创建都是创建一个新的字符串把地址赋给这个对象。StringBuffer、StringBuilder都是可变的，不同的是StringBuffer类中的方法都加了synchronized关键字，是线程安全的。StringBuilder是线程不安全的，但是速度最快。
###	重载和重写的不同
重载是在一个类中方法名相同参数不同，提供多个方法的。重写是子类重写父类的方法。重载对返回类型没有要求，但是重写需要兼容父类的返回对象。重载的参数个数和类型不同，重写必须相同。重载对修饰符没有特殊的要求，但是重写修饰符一定大于等于父类的修饰符。
###	java类的加载过程
java类加载有三个阶段，加载、连接和初始化。连接分为验证、准备和解析。
加载由类加载器完成，class文件读入内存后，将其保存到方法区，就会创建一个class类型的对象。
验证就是确保class文件的字节流中包含的信息符合当前虚拟机的要求，保证被加载类的正确性不会危害虚拟机自身的安全
准备为类的静态变量分配内存并且分配初始值。
解析是将常量池中的符号引用替换为直接引用的过程
初始化，则是为标记常量值的字段赋值的过程。
###	JVM GC内存回收机制
JVM的内存区分为新生代、老年代和元空间，我们产生的新对象都会先分配到新生代的eden区，然后eden区满了，则会触发一次新生代的GC,存活下来的则会放入新生代的Survivor区，如果增长到一定年龄15岁，则会放入到老年区。一些比较大的对象也会直接放入到老年区，比如说字符串和数组。
如果老年代不足以容纳新的对象时，就会触发老年代GC,如果老年代也满了就会抛出异常内存溢出。
###	说一下JVM的内存结构
jvm的内存分为堆栈和方法区还有程序计数器，堆是jvm最大的存储，是所有线程共享的，主要分为新生代，和老年代。
栈是线程私有的空间，主要结构是栈帧。栈帧主要的结构有局部变量表，操作数栈，动态连接和返回地址等。
永久方法区主要存放的是类信息，常量和静态变量，也就是编译器编译后的代码，还有常量池。堆和方法区是所有线程共有的
###	JVM调优有什么原则
GC的时间小，GC的次数少。尽量Full GC的时间足够的长。
堆的最大Xmx和最小值Xms设置在相同的值，防止收缩和扩大
###	java反射是什么
java反射是指在运行时态获取类的信息，调用对象的方法，操作对象的属性等，可以让程序在运行时通过类名，方法名和属性名来访问java多项内部信息，实现动态编程。
##	集合类相关
###	Hashtable与HashMap的区别
Hashtable是线程安全的，HashMap是线程不安全的。Hashtable的key不允许为null,HashMap的key允许为null。Hashtable的hash是取的key的hash，但是HashMap的hash是根据算法新生成的。Hashtable初始容量是11，扩容是2n+1。HashMap初始容量是16，扩容是2n。其他在使用上也有一些不同，如迭代器不一样，hashtable 还有contains方法等
###	HashMap在多线程中会产生什么问题
因为使用了头插法，两个线程同时插入的时候会出现死循环，这个在1.7之后改为了尾插法就不会出现了
多线程的put可能导致元素的丢失
put和get并发时可能会导致get为null
###	有哪些线程安全的map类
HashTable:是直接在操作方法上加synchronized 关键字，锁住整个 table 数组。
synchronizedMap：是实现了Map接口，在调用的时候加上了synchronized 关键字
ConcurrentHashMap ：1.7用的是分段锁，1.8中使用了CAS和synchronized
###	ArrayList和LinkedList的区别
ArrayList是通过动态数组来实现存储的。LinkedList是使用双向链表来存储的。因为这种结构上的不同ArrayList随机访问比较快，而linkedList删除和增加会比较快
###	有哪些线程安全的List
Vector：实现原理和hashmap相似，内部都使用synchronized 加锁，操作很慢。
synchronizedList:也是在所有操作上加synchronized ，本质就是对整个list加锁。
CopyonWriteArrayList：新增的时候是加锁复制新增元素，get是没有加锁的，所以比较适合读多写少的场景

##	多线程
###	多线程的实现方式
继承Tread类，实现Runnable，Callable接口，或者使用线程池。
###	多线程执行的几种方式的区别
Runnable是接口，实现之后不影响类的继承，Callable可以返回参数，线程池实际上是对线程的一种管理工具。
###	你们在哪里实际用过多线程
其实之前用的地方还是比较多的，一般都是并行处理数据的场景，在上个项目中，我们一个功能是校验两个系统之间的数据用来检查转账数据是否一致的功能，算是一个系统数据监控的功能。因为数据量比较大，所以我们就循环拆开数据1000条数据new一线程去对比。
####	说一下具体你们是怎么对比两个库的数据
是这样的，这边转账的系统是我们系统接受到前端项目的请求之后处理数据，我们这边是持久化的，实际转账的系统的另一个系统在做，数据库也不在一起，所以才会出现这种对比数据的需求，实际转账的系统那边团队会定时查询一个时间范围内的数据放到execl表格当中，让后放到sftp一个服务器中。然后我们从sftp上拿到表格之后取出来数据到list里面，然后我们这边直接查数据库在这个时间范围内的数据，然后我们这边拆分出来1000条就new一个线程和那边所有的数据进行对比，这样并行对比数据会比两个for循环在主线程里面快一些。然后线程我们使用的是callable线程，会返回一个他们那边没有的数据的list，最后我们再主线程里面合并到一起。

###	线程池主要有哪些？
线程池主要的种类有
简单线程池SingleThreadExecutor
固定线程池FixedThreadPool
无限扩大线程池CachedThreadPool
延迟启动线程池ScheduledThreadPool，
多队列任务线程池。
### *你在什么地方用过线程池*
之前在一个项目当中用过，但是忘记了那个项目。好像是批量call接口的功能，我们的项目必支持批量操作，但是下游系统没有批量操作的接口，临时就用了线程池这种方法call下游接口


###	说一下并发和并行有什么区别
并发是交替执行，多个线程快速的交替执行，在宏观上看着是同时执行的，但是在微观上并不是同时的。并行是在多个处理器上同时执行，不管是在宏观还是微观上都是同时的
###	说一下sleep和wait的区别
sleep不一定必须在同步方法中，但是wait必须在同步方法中。sleep方法是Thread类中定义的方法，wait是object类中定义的。sleep不会释放锁和系统资源，wait会释放锁和系统资源，其他线程可以占用CPU。sleep必须指定时间结束或者使用interrupt强行停止，wait可以设定时间结束停止，或者使用notify来唤醒。sleep是静态方法，wait是实例方法。sleep必须捕获异常，wait，notify则不用捕获异常。
###	说一下多线程的生命周期
新建、就绪、运行、阻塞和死亡。
新建是new一个新的线程，该线程处于新建状态，处于新建状态的线程有自己的内存空间，通过srart方法进入就绪状态。就绪状态就是线程具备了运行的条件，但是还没有分配到cpu，等待系统分配资源。运行状态就是线程执行run方法中的代码。阻塞状态是线程处于运行状态的时候如果执行了sleep或者等待资源的时候会让出CPU并暂停自己的运行，进入阻塞状态。在阻塞状态的线程不能进入就绪队列，只有当阻塞的原因消除的时候才能转入就绪状态。死亡状态是线程的生命周期最后一个阶段，死亡的原因有三个，一个是正常结束，一个是被强制性终止，三是抛出未捕获的异常。
###	你知道多少锁的概念，简单的说下
公平锁/非公平锁：公平锁是指多个线程按照申请锁的顺序来获取锁的，非公平锁则不是按照申请锁的顺序来的。
乐观锁/悲观锁：乐观锁和悲观锁的的概念并不是具体指的哪种类型的锁，主要是指看待并发同步的角度。悲观锁认为一个数据并发一定会被修改会出问题，一般情况就是加各种锁。乐观锁则认为数据一般并发操作时不会被修改的不会发生问题，一般就是不加锁或者使用CAS自旋。
独享锁/共享锁：独享锁就是只能被一个线程占有，共享锁可以被多个线程持有。lock的实现类里面ReentrantLock是独享锁，而ReentrantReadWriteLock读是共享锁，写是独享锁。Synchronized是独享锁。ReentrantLock这种都是独享锁的实现也叫做互斥锁，而ReentrantReadWriteLock这种实现也叫做读写锁。
还有可重入锁，是指一个线程在一个方法中获取锁的时候内部的方法也能自动获取锁，ReentreantLock和synchronize都是可重入锁。
###	你对synchronize有多少了解，说一下
synchronize在jdk1.5之前没什么可说的，没有任何优化，就是在系统底层加锁，在jdk1.6之后做了比较多的优化，加了自旋、锁消除、锁粗化、轻量级锁和锁偏向等，效率上有很大提高。
###	说一下synchronize的几种锁状态和它们如何升级的
synchronize在JDK1.6之后就有了无锁，偏向锁，轻量级锁和重量级锁4种状态，锁状态只能升级不能降级。
无锁就是系统系统在代码上还没有加任何锁锁标志位是00,如果有了第一个线程来获取锁，就会升级成为偏向锁，锁标志位就是01了，现在就是可偏向的状态，如果第二次获取锁的的线程还是这个，那么直接执行代码，如果下次来的线程不是这个线程了，那么锁就会升级成为轻量级锁，轻量级锁每次进来都会用CAS的方式获取锁，执行完会释放锁。如果当有另外的线程进来竞争锁的时候，CAS自旋也获取锁失败，锁就会最终升级为重量级锁，重量级锁就会调用系统底层的metex lock来加锁处理了
###	说一下lock和synchronize的区别
synchronize不需要释放锁，lock需要释放锁。synchronize是非公平锁，lock的实现类可以设置为公平锁。lock可以设置等待时间，lock的实现类可以实现可读写锁，synchronize只要锁住也不能读。Lock可以知道是否获取到锁。Synchronize1.5之前都是采用悲观锁的，lock一直是采用乐观锁的，会使用CAS重试直到成功。
###	lock有哪些常用的实现类
ReentrantLock，ReadWriteLock和ReentrantReadWriteLock,一般我用的比较多的时ReentrantReadWriteLock，读锁和写锁分开，又有类似偏向锁的可重入锁机制。
###	怎么查找解决和避免死锁
死锁就是多个线程互相竞争对方已经占用的资源。查找的话一般可以使用java的工具Jconsole和Jvisualvm来排查，可以看到发生死锁的代码。
避免死锁主要尽量使用无锁编程，尽可能缩写锁的范围，需要获取多个锁的时候设计锁的顺序，使用定时锁，自旋锁像是trylock
###	synchronize可以用在哪些地方
普通方法，同步静态方法，同步类，同步this实例，同步对象实例等，一般如果要使用的话一般是使用在同步方法上
###	同步块和同步方法
一般情况下同步块的范围比较小，这样也性能比较好，而同步方法，是整个方法加锁，如果同步块的对象是this的情况下，那么同步块和同步方法是一样的。
###	说一下volitile关键字的作用和原理
原理就是在每次操作volitile修饰的对象后把最新的值写入到计算机的主内存中而不是写入到缓存和cpu缓存中。作用主要是保证变量操作的可见性
###	多线程怎么顺序执行
其实实现的方法有很多，一般可以使用join关键字，有使用线程join的方式，主线程join的方式。可以使用wait,notify。当然我看还有其他条件变量、信号量的方式，我这边没有用过。
###	说一下线程池的运行机制
线程池其实是一个hashset，如果在核心线程数量没有满则会执行任务，如果核心线程池满了则会加入到缓存队列，如果核心线程池也满了，则会检查是否超过了线程池的最大数量，如果没有超过也是执行任务，如果超过了则会使用hander处理拒绝加入队列。

#	Redis
##	Redis分布式锁实现原理
redis可以使用原生的setnx去实现分布式锁，但是可能出现单节点失效、释放锁不能原子化等问题。一般现在会使用redission框架去实现分布式锁，可以解决这些问题。redission使用了看门狗的机制，每隔十秒钟就会自动续期30s，如果机器宕机了，看门口也会失效。redission也使用lua脚本，所有的操作都是原子化的。
##	Redis有哪些数据类型，可以简单的说下
String、List、Hash、Set
##	Redis有哪些持久化的方案，有什么优缺点
redis有两种持久化的方案，Rob和AOF,Rob这是保存数据快照，就是设置定时保存当前的数据，所以保存的数据可能不是最新的，但是恢复速度快，性能好，文件小。AOF就是以日志的方式保存每次写入的命令，所以它的恢复回来数据是最新的，速度慢，性能差一点，当然可以定期的执行重写操作来降低文件的体积。
##	Redis为什么比较快
主要因为是基于内存的，绝大部分的请求都是在内存中操作的。还有数据结构简单，采用单线程，多路IO复用等。
##	Redis雪崩是什么意思，解决办法有哪些
一般在一个系统中，缓存层承载了大量的请求。如果某些原因缓存不能整体的提供服务的时候，请求就会直接到达数据库，请求量过大造成了数据库的崩溃。
出现这一问题的场景有可能是大量缓存在同一时间失效，redis单节点失效等。主要的解决办法是让设置缓存时间的时候尽量然失效的时间均匀些，做redis的高可用，做二级缓存，设置热点数据，做互斥锁，使用sentinel 或者hystrix做一层限流，做一些告警等等。
##	Redis穿透和击穿说下，怎么解决
穿透主要可能是有恶意攻击故意调用不存在的数据直接查到数据库，被后端系统和数据库造成很大的压力。主要解决办法有缓存不存在的结果，做限流，做一些ID或者其他数据的校验等。
缓存击穿就是很多数据在同一时间缓存到期，比较多的请求直接到数据库这种场景。主要解决办法尽量然失效的时间均匀些，做redis的高可用，做二期缓存，设置热点数据，做互斥锁，做限流等等
##	说一下redis的互斥锁
其实就是在从数据库获取数据的时候加个锁，然后如果还没有查询完数据库又有一个线程需要查数据库，那么久等待一个很短的时候再去缓存里面查询key,这样可以保证在短时间内不会打到数据库的请求太多。
##	说一下redis的集群
redis的集群主要有几种模式吧，主从模式，哨兵模式，集群模式，客户端分片等。主从模式就是有个主服务器，然后有几个从服务器，主要是降低读取的高可用。哨兵模式的话其实也是主从模式的改进，在主服务器出现故障的时候会自动转移，选举出主服务器。集群模式是redis3.0之后支持redis-cluster集群，去中心化，能解决写的高可用和压力，客户端分片就是在我们程序中根据一定规则放到不同的redis服务器中。
##	怎么保证缓存和数据库数据的一致性
这个其实也没有什么统一的方案，我们之前有项目主要是使用更新数据库之后删除缓存，这种方法可能会在删除缓存的时候失败，可以加个重试的机制，但是我记得那个项目是没来记得加的，因为我们没有遇到过失败的情况。其实这个一致性的问题还是看项目和需求看情况解决吧。
##	Redis分布式锁使用要注意什么
保证业务代码加锁和解锁可以正常，要考虑粒度，注意锁超时，考虑是否持久化，考虑高可用，尽量设置的字段有一些特点避免误删。

#	消息队列
##	为什么使用消息队列
消息队列主要的作用是是解耦、异步和削峰。
解耦就是如果一个系统要同时调用其他系统中的其他接口，如果每次加接口的话每次都要修改这个接口的数据，但是使用消息队列，然后使用订阅的方式，只在下游接口订阅这个消息队列进行消费就可以了。
异步就是如果一个用户操作要进行很多的后台操作，会话费很长的时间就会使用到异步的属性，可以让用户操作更流畅，不影响用户的下一步操作。
削峰就是如果一个系统平常的流量比较低，但是如果在一瞬间有很大流量的话，就会让 数据库承受很大的压力，如果加入mq,那么就可以高峰之后慢慢入库。
##	常见的消息队列和他们的优缺点
常见的消息队列有RabbitMQ、RocketMQ和kafka.
RabbitMQ的主要特点是支持磁盘和内存持久化，支持少量堆积。支持事务，支持集群，但是只支持复制模式，不支持顺序消息，不支持消息回溯，不支持消息重试，并发极高。
RocketMQ的主要特点是只支持磁盘持久化，支持大量堆积。支持事务，支持集群，但是开源版本只能手动切换
##	怎么保证消息队列消息不丢失
<<<<<<< HEAD
我之前用的RocketMQ，主要考虑了几个方面吧，生产端保证发送成功到消息队列判断返回的消息就可以了，如果需要需要保证完全不会丢失可以开始同步刷盘。消息队列RocketMQ服务方面主要是搞高可用。消费者方面可以通过消费者返回的消息是成功就是消费成功，如果返回later，null或者抛出异常了就是消费失败了会重试，如果不希望重试可以返回C##mmitMessage，消费重试最多16次，超过16次会进入死信。
=======
如RocketMQ，主要考虑了几个方面吧，生产端保证发送成功到消息队列判断返回的消息就可以了，如果需要需要保证完全不会丢失可以开始同步刷盘。消息队列RocketMQ服务方面主要是搞高可用。消费者方面可以通过消费者返回的消息是成功就是消费成功，如果返回later，null或者抛出异常了就是消费失败了会重试，如果不希望重试可以返回CommitMessage，消费重试最多16次，超过16次会进入死信。
>>>>>>> main
RabbitMQ这边我也了解过，生产者可以开始事务和确认模式，broker开启队列持久化和消息持久化。然后消费者，关闭自动ack，在消费失败的情况下情况下返回nack。
#	分布式
##	分布式事务的实现方式
主要的实现方式有两段式三段式提交，ebay事件消息队列，和TCC补偿模式。两段式提交就是一个业务执行完业务代码后先不提交，通知其他参与的服务也提交业务代码。TCC就是记录下所有的操作记录，哪一步出问题了就后面从业务上回滚数据。Ebay主要的方法就是记录下所有的关键操作的事件队列，然后发生异常之后就重试，保证最终一致性。
#	开发大类问题
##	Session和cookie的区别
Session是存储在服务器端的，比较安全，value是object，存储的大小没有限制，一般用来存储登录信息，操作信息等。cookie存储在客户端，不是很安全，value只能是字符串的，大小最大3k,一般同来存储及用户名密码和网站设置能信息的。
##	深拷贝和浅拷贝
深拷贝就是复制之后在磁盘上不一个对象，浅拷贝就是就是引用拷贝。
##	接口开发需要考虑什么问题
接口的名字要能看出来是什么接口，参数，异常和超时返回错误，幂等性，符合restful规范，限流降级容错，缓存，是否需要多个负载均衡，db存储，并发数，响应时间等，如果对外的接口提供版本号
##	什么场景下可以使用长连接，什么情况下使用短连接。
长连接适用于和服务器频繁通信的场景，比如说推送，实时游戏，实时通讯等，这样可以降低频繁连接断开的消耗，和负载，提高系统性能。
短连接适用于与服务器不需要频繁通讯的场景，如http网络请求，请求完之后就会断开，节省服务器资源和提高并发能力。
##	http怎么设置长连接
在请求头中设置Connection: keep-alive，表示请求完成后保持连接，不会立即关闭连接，以便于下次请求复用该连接，提高连接的利用率。
HTTP长连接并不意味着连接会一直保持不关闭，而是在保持一定时间内没有通信时，会被服务器主动关闭，以释放资源。因此，长连接的实现需要考虑合理的超时时间。可以使用timeout来设置超时时间。
##	http默认是长连接还是短连接
HTTP/1.0默认使用短连接，每次请求完毕都会断开连接
而HTTP/1.1默认使用长连接，可以在一个TCP连接上发送和接收多个HTTP请求和响应。
##	数据结构
###	怎么实现一个链表
定义一个节点类，包含数据和指向下一个节点的指针
定义链表类，包含一些操作方法，添加删除查找和遍历等
在构造函数中构造函数的头节点指针，然后测试一下。
###	怎么实现一个二叉树
也和链表一样，定义一个节点类，包含结点值，左子树和右子树三个值
然后定义二叉树类，插入查找和遍历等。
#	编码技巧
##	查找list集合中某个元素
使用for循环查找，使用lambda中的anyMatch，filter，放到hashmap中快速查找。
#	Linux服务器
##	chmod 777 每一个7分别针对的是那个级别的用户
chmod 777 命令中每一个 7 分别表示文件或目录权限中的三个不同级别的用户：所有者、所属组和其他用户。具体来说，第一个 7 表示所有者权限，第二个 7 表示所属组权限，第三个 7 表示其他用户权限。
7表示读取、写入和执行权限,是4读取2写入和1执行权限加起来的
##	Linux中top命令用来做什么
top 命令用于查看系统资源的实时状态，包括进程、CPU、内存、IO等。加d是date时间，p是进程号，u是用户。这三个参数用的比较多
##	如果服务器出现卡顿，怎么排查
查看日志文件，这个要查看系统日志，引用程序日志等，检查系统的负载，可以使用top等系统工具。查看网络连接状况，使用ping或者使用telnet工具。然后还可以查看应用是否有死锁，内存泄露，频繁GC，看下数据库是否有死锁，慢查询等
##	一般部署服务器会给服务器的文件夹或者包配置什么权限
用户访问，执行和读取，如果需要修改就加入写入权限，还有一些文件夹需要访问需要网络访问权限。
#	个人素质
## *自学情况-主要看看平时有没有看书或者去学习*
有，在工作比较稳的时候，周末或者下班回家会找一些框架的教程去看，主要就是看慕课网的事情等。看过Spring security，小程序等
##	*你觉得你有什么优点和缺点*
我觉得我优点是比较有耐心，善于钻研问题，我们在日常开发中经常会遇到问题不好解决的，我经常会几天都在解决一个不好搞的问题。缺点就是觉得有时自己比较懒，有些事情可能会比较拖，但是自己也在一直克服这个问题吧。
##	*你对加班怎么看*
其实在这个行业加班也是很正常的事情，像是发布上线，赶进度或者自己的问题加班都是可以理解的。
##	*你怎么看待996*
在工资合适的情况下996或者大小周是没问题的，但是我也不是太喜欢为了996而996的，希望能完成工作就能正常下班，如果任务紧急或者个人问题，加班也是也是可以的。
##	*你处理过什么比较难的问题*
